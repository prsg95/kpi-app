name: "Deploy DMS Api"

trigger: none

pool:
  name: 'xd-agents-dev-windows-west-europe'

variables:
  - name: buildPlatform
    value: 'Any CPU'
  - name: buildConfiguration
    value: 'Release'

stages:
  - stage: DeployDev
    displayName: 'Deploy Dev'
    condition: always()
    jobs:
    - job: Deploy
      displayName: 'Deploy Dev Build'
      variables: 
        - group: Dms-Kpi-Dev
      steps:

      # Step 1: Fetch Build ID Based on Tag
      - powershell: |
          $artifactTag = "$(buildTag)"
          $pipelineid = "$(pipelineId_Be)"
          $uri = "https://dev.azure.com/SimCorpCloud/DevOps-IE/_apis/build/builds?tagFilters=$artifactTag&definitions=$pipelineid&api-version=7.1"
          $pat = "$(System.AccessToken)"
          $headers = @{ Authorization = "Bearer $pat" }

          # Make the API call
          $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get

          # Extract the latest build ID with the specified tag
          if ($response.count -eq 0) {
              Write-Error "No builds found with tag $(artifactTag)"
              exit 1
          }

          $buildId = $response.value[0].id  # Use the first (latest) build

          Write-Host "##vso[task.setvariable variable=buildId]$buildId"
          Write-Host "Build ID retrieved: $buildId"
        displayName: 'Fetch Build ID Based on Tag'

      # Step 2: Download the Artifact Using Build ID
      - task: DownloadPipelineArtifact@2
        displayName: 'Download Artifact from Build Pipeline'
        inputs:
          buildType: 'specific'
          project: 'DevOps-IE'
          pipeline: 'Build dms-cockpit-api'
          tags: 'dev'
          artifact: 'drop'
          path: '$(Pipeline.Workspace)'

      # Step 3: List the contents of the drop folder to verify
      - powershell: |
          Write-Host "Checking contents of the drop folder..."
          Get-ChildItem -Path "$(Pipeline.Workspace)" -Recurse
        displayName: 'Verify Artifact Download'

      # Remaining Steps: Authentication, Unzipping, Secrets, and Deployment (unchanged from your original)
      - script: |
          echo "Authenticating to Azure..."
          az login --service-principal --username "$(AZURE_CLIENT_ID)" --password "$(AZURE_CLIENT_SECRET)" --tenant "$(AZURE_TENANT_ID)"
        displayName: 'Azure CLI Authentication'

      - powershell: |
          Write-Host "Unzipping the artifact..."
          Expand-Archive -Path "$(Pipeline.Workspace)\s.zip" -DestinationPath "$(Pipeline.Workspace)\extracted" -Force
        displayName: 'Unzip Artifact'

      - powershell: |
          echo "Fetching secrets from Azure Key Vault..."
          $dbserver = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpidevsqlserver" --query "value" -o tsv
          $dbUser = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpidevsqluser" --query "value" -o tsv
          $dbPassword = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpidevsqlpass" --query "value" -o tsv
          $oemUser = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpidevoem" --query "value" -o tsv
          $oemPassword = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpidevoempass" --query "value" -o tsv
          $oemAddr = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpidevoembaseaddr" --query "value" -o tsv

          Write-Host "Secrets fetched successfully!"
          
          Write-Host "##vso[task.setvariable variable=dbserver]$dbserver"
          Write-Host "##vso[task.setvariable variable=dbUser]$dbUser"
          Write-Host "##vso[task.setvariable variable=dbPassword]$dbPassword"
          Write-Host "##vso[task.setvariable variable=oemUser]$oemUser"
          Write-Host "##vso[task.setvariable variable=oemPassword]$oemPassword"
          Write-Host "##vso[task.setvariable variable=oemAddr]$oemAddr"

        displayName: 'Fetch Secrets from Key Vault'

      - powershell: |
          $appSettingsPath = "$(Pipeline.Workspace)\extracted\appsettings.json"

          if (-Not (Test-Path $appSettingsPath)) {
              Write-Error "appsettings.json not found at path: $appSettingsPath"
              exit 1
          }

          $appSettings = Get-Content $appSettingsPath -Raw | ConvertFrom-Json

          $appSettings.ConnectionStrings.DefaultConnection = $appSettings.ConnectionStrings.DefaultConnection -replace "<server>", $env:dbserver -replace "<sqluser>", $env:dbUser -replace "<sqlpass>", $env:dbPassword
          $appSettings.Credentials.BaseAddress = "$(baseaddr)"
          $appSettings.Credentials.Username = $env:oemUser
          $appSettings.Credentials.Password = $env:oemPassword
          $appSettings.AuthenticationSettings.ValidAudience = "$(app_uri)"
          $appSettings.AzureLogAnalytics.TenantId = "$(AZURE_TENANT_ID)"
          $appSettings.AzureLogAnalytics.ClientId = "$(AZURE_CLIENT_ID)"
          $appSettings.AzureLogAnalytics.ClientSecret = "$(AZURE_CLIENT_SECRET)"


          $appSettings | ConvertTo-Json -Depth 10 | Set-Content $appSettingsPath

          Write-Host "appsettings.json updated with Key Vault secrets."
          
          $updatedContent = Get-Content $appSettingsPath -Raw
          # Write-Host "Updated appsettings.json contents: $updatedContent"
        displayName: 'Update appsettings with secrets'

      - powershell: |
          Write-Host "Zipping the updated contents..."
          $zipPath = "$(Pipeline.Workspace)\updated.zip"
          Compress-Archive -Path "$(Pipeline.Workspace)\extracted\*" -DestinationPath $zipPath -Force
        displayName: 'Zip Updated Contents'

      - script: |
          echo "Deploying to Azure App Service..."
          az webapp deployment source config-zip --subscription "$(AZURE_SUBSCRIPTION_ID)" --resource-group "$(rg_name)" --name "$(app_name)" --src $(Pipeline.Workspace)/updated.zip
        displayName: 'Deploy to Azure App Service'


  - stage: DeployTest
    displayName: "Deploy Test"
    dependsOn: DeployDev
    condition: succeeded()
    jobs:
      - job: Deploy
        displayName: 'Deploy Test Build'
        variables:
          - group: Dms-Kpi-Test
        steps:
            
          # Step 1: Fetch Build ID Based on Tag
        - powershell: |
            $artifactTag = "$(buildTag)"
            $pipelineid = "$(pipelineId_Be)"
            $uri = "https://dev.azure.com/SimCorpCloud/DevOps-IE/_apis/build/builds?tagFilters=$artifactTag&definitions=$pipelineid&api-version=7.1"
            $pat = "$(System.AccessToken)"
            $headers = @{ Authorization = "Bearer $pat" }

            # Make the API call
            $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get

            # Extract the latest build ID with the specified tag
            if ($response.count -eq 0) {
                Write-Error "No builds found with tag $(artifactTag)"
                exit 1
            }

            $buildId = $response.value[0].id  # Use the first (latest) build

            Write-Host "##vso[task.setvariable variable=buildId]$buildId"
            Write-Host "Build ID retrieved: $buildId"
          displayName: 'Fetch Build ID Based on Tag'
        
          # Step 2: Download the Artifact Using Build ID
        - task: DownloadPipelineArtifact@2
          displayName: 'Download Artifact from Build Pipeline'
          inputs:
            buildType: 'specific'
            project: 'DevOps-IE'
            pipeline: 'Build dms-cockpit-api'
            tags: 'test'
            artifact: 'drop'
            path: '$(Pipeline.Workspace)'

        # Step 3: List the contents of the drop folder to verify
        - powershell: |
            Write-Host "Checking contents of the drop folder..."
            Get-ChildItem -Path "$(Pipeline.Workspace)" -Recurse
          displayName: 'Verify Artifact Download'

        # Remaining Steps: Authentication, Unzipping, Secrets, and Deployment (unchanged from your original)
        - script: |
            echo "Authenticating to Azure..."
            az login --service-principal --username "$(AZURE_CLIENT_ID)" --password "$(AZURE_CLIENT_SECRET)" --tenant "$(AZURE_TENANT_ID)"
          displayName: 'Azure CLI Authentication'

        - powershell: |
            Write-Host "Unzipping the artifact..."
            Expand-Archive -Path "$(Pipeline.Workspace)\s.zip" -DestinationPath "$(Pipeline.Workspace)\extracted" -Force
          displayName: 'Unzip Artifact'

        - powershell: |
            echo "Fetching secrets from Azure Key Vault..."
            $dbserver = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpitestsqlserver" --query "value" -o tsv
            $dbUser = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpitestsqluser" --query "value" -o tsv
            $dbPassword = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpitestsqlpass" --query "value" -o tsv
            $oemUser = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpitestoemuser" --query "value" -o tsv
            $oemPassword = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpitestoempass" --query "value" -o tsv
            $oemAddr = az keyvault secret show --vault-name "$(vault_name)" --name "dmskpitestoembaseaddr" --query "value" -o tsv

            Write-Host "Secrets fetched successfully!"
            
            Write-Host "##vso[task.setvariable variable=dbserver]$dbserver"
            Write-Host "##vso[task.setvariable variable=dbUser]$dbUser"
            Write-Host "##vso[task.setvariable variable=dbPassword]$dbPassword"
            Write-Host "##vso[task.setvariable variable=oemUser]$oemUser"
            Write-Host "##vso[task.setvariable variable=oemPassword]$oemPassword"
            Write-Host "##vso[task.setvariable variable=oemAddr]$oemAddr"

          displayName: 'Fetch Secrets from Key Vault'

        - powershell: |
            $appSettingsPath = "$(Pipeline.Workspace)\extracted\appsettings.json"

            if (-Not (Test-Path $appSettingsPath)) {
                Write-Error "appsettings.json not found at path: $appSettingsPath"
                exit 1
            }

            $appSettings = Get-Content $appSettingsPath -Raw | ConvertFrom-Json

            $appSettings.ConnectionStrings.DefaultConnection = $appSettings.ConnectionStrings.DefaultConnection -replace "<server>", $env:dbserver -replace "<sqluser>", $env:dbUser -replace "<sqlpass>", "$(sqlAdminPass)"
            $appSettings.Credentials.BaseAddress = "$(baseaddr)"
            $appSettings.Credentials.Username = $env:oemUser
            $appSettings.Credentials.Password = $env:oemPassword
            $appSettings.AuthenticationSettings.ValidAudience = "$(app_uri)"
            $appSettings.AzureLogAnalytics.TenantId = "$(AZURE_TENANT_ID)"
            $appSettings.AzureLogAnalytics.ClientId = "$(AZURE_CLIENT_ID)"
            $appSettings.AzureLogAnalytics.ClientSecret = "$(AZURE_CLIENT_SECRET)"


            $appSettings | ConvertTo-Json -Depth 10 | Set-Content $appSettingsPath

            # Write-Host "appsettings.json updated with Key Vault secrets."
            
            $updatedContent = Get-Content $appSettingsPath -Raw
            Write-Host "Updated appsettings.json contents: $updatedContent"
          displayName: 'Update appsettings with secrets'

        - powershell: |
            Write-Host "Zipping the updated contents..."
            $zipPath = "$(Pipeline.Workspace)\updated.zip"
            Compress-Archive -Path "$(Pipeline.Workspace)\extracted\*" -DestinationPath $zipPath -Force
          displayName: 'Zip Updated Contents'

        - script: |
            echo "Deploying to Azure App Service..."
            az webapp deployment source config-zip --subscription "$(AZURE_SUBSCRIPTION_ID)" --resource-group "$(rg_name)" --name "$(app_name)" --src $(Pipeline.Workspace)/updated.zip
          displayName: 'Deploy to Azure App Service'


  - stage: DeployProd
    displayName: "Deploy Prod"
    dependsOn: DeployTest
    condition: succeeded()
    jobs:
      - job: Deploy
        displayName: 'Deploy Prod Build'
        variables:
          - group: Dms-Kpi-Prod
        steps:
            
          # Step 1: Fetch Build ID Based on Tag
        - powershell: |
            $artifactTag = "$(buildTag)"
            $pipelineid = "$(pipelineId_Be)"
            $uri = "https://dev.azure.com/SimCorpCloud/DevOps-IE/_apis/build/builds?tagFilters=$artifactTag&definitions=$pipelineid&api-version=7.1"
            $pat = "$(System.AccessToken)"
            $headers = @{ Authorization = "Bearer $pat" }

            # Make the API call
            $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get

            # Extract the latest build ID with the specified tag
            if ($response.count -eq 0) {
                Write-Error "No builds found with tag $(artifactTag)"
                exit 1
            }

            $buildId = $response.value[0].id  # Use the first (latest) build

            Write-Host "##vso[task.setvariable variable=buildId]$buildId"
            Write-Host "Build ID retrieved: $buildId"
          displayName: 'Fetch Build ID Based on Tag'
        
          # Step 2: Download the Artifact Using Build ID
        - task: DownloadPipelineArtifact@2
          displayName: 'Download Artifact from Build Pipeline'
          inputs:
            buildType: 'specific'
            project: 'DevOps-IE'
            pipeline: 'Build dms-cockpit-api'
            tags: 'prod'
            artifact: 'drop'
            path: '$(Pipeline.Workspace)'

        # Step 3: List the contents of the drop folder to verify
        - powershell: |
            Write-Host "Checking contents of the drop folder..."
            Get-ChildItem -Path "$(Pipeline.Workspace)" -Recurse
          displayName: 'Verify Artifact Download'

        # Remaining Steps: Authentication, Unzipping, Secrets, and Deployment (unchanged from your original)
        - script: |
            echo "Authenticating to Azure..."
            az login --service-principal --username "$(AZURE_CLIENT_ID)" --password "$(AZURE_CLIENT_SECRET)" --tenant "$(AZURE_TENANT_ID)"
          displayName: 'Azure CLI Authentication'

        - powershell: |
            Write-Host "Unzipping the artifact..."
            Expand-Archive -Path "$(Pipeline.Workspace)\s.zip" -DestinationPath "$(Pipeline.Workspace)\extracted" -Force
          displayName: 'Unzip Artifact'

        - powershell: |
            echo "Fetching secrets from Azure Key Vault..."
            $dbserver = az keyvault secret show --vault-name "$(vault_name)" --name "kpiprodsqlserver" --query "value" -o tsv
            $dbUser = az keyvault secret show --vault-name "$(vault_name)" --name "kpiprodsqluser" --query "value" -o tsv
            $dbPassword = az keyvault secret show --vault-name "$(vault_name)" --name "kpiprodsqlpass" --query "value" -o tsv
            $oemUser = az keyvault secret show --vault-name "$(vault_name)" --name "kpiprodoemuser" --query "value" -o tsv
            $oemPassword = az keyvault secret show --vault-name "$(vault_name)" --name "kpiprodoempass" --query "value" -o tsv
            $oemAddr = az keyvault secret show --vault-name "$(vault_name)" --name "kpiprodoembaseaddr" --query "value" -o tsv

            Write-Host "Secrets fetched successfully!"
            
            Write-Host "##vso[task.setvariable variable=dbserver]$dbserver"
            Write-Host "##vso[task.setvariable variable=dbUser]$dbUser"
            Write-Host "##vso[task.setvariable variable=dbPassword]$dbPassword"
            Write-Host "##vso[task.setvariable variable=oemUser]$oemUser"
            Write-Host "##vso[task.setvariable variable=oemPassword]$oemPassword"
            Write-Host "##vso[task.setvariable variable=oemAddr]$oemAddr"

          displayName: 'Fetch Secrets from Key Vault'

        - powershell: |
            $appSettingsPath = "$(Pipeline.Workspace)\extracted\appsettings.json"

            if (-Not (Test-Path $appSettingsPath)) {
                Write-Error "appsettings.json not found at path: $appSettingsPath"
                exit 1
            }

            $appSettings = Get-Content $appSettingsPath -Raw | ConvertFrom-Json

            $appSettings.ConnectionStrings.DefaultConnection = $appSettings.ConnectionStrings.DefaultConnection -replace "<server>", $env:dbserver -replace "<sqluser>", $env:dbUser -replace "<sqlpass>", $env:dbPassword
            $appSettings.Credentials.BaseAddress = "$(baseaddr)"
            $appSettings.Credentials.Username = $env:oemUser
            $appSettings.Credentials.Password = $env:oemPassword
            $appSettings.AuthenticationSettings.ValidAudience = "$(app_uri)"
            $appSettings.AzureLogAnalytics.TenantId = "$(AZURE_TENANT_ID)"
            $appSettings.AzureLogAnalytics.ClientId = "$(AZURE_CLIENT_ID)"
            $appSettings.AzureLogAnalytics.ClientSecret = "$(AZURE_CLIENT_SECRET)"

            $appSettings | ConvertTo-Json -Depth 10 | Set-Content $appSettingsPath

            Write-Host "appsettings.json updated with Key Vault secrets."
            
            $updatedContent = Get-Content $appSettingsPath -Raw
            # Write-Host "Updated appsettings.json contents: $updatedContent"
          displayName: 'Update appsettings with secrets'

        - powershell: |
            Write-Host "Zipping the updated contents..."
            $zipPath = "$(Pipeline.Workspace)\updated.zip"
            Compress-Archive -Path "$(Pipeline.Workspace)\extracted\*" -DestinationPath $zipPath -Force
          displayName: 'Zip Updated Contents'

        - script: |
            echo "Deploying to Azure App Service..."
            az webapp deployment source config-zip --subscription "$(AZURE_SUBSCRIPTION_ID)" --resource-group "$(rg_name)" --name "$(app_name)" --src $(Pipeline.Workspace)/updated.zip
          displayName: 'Deploy to Azure App Service'
